//$file${.::blinky.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: blinky.qm
// File:  ${.::blinky.cpp}
//
// This code has been generated by QM 5.2.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::blinky.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"
#include "blinky2.hpp"
#include <iostream>
#include <cstdlib> // for exit()

using namespace std;
using namespace QP;
Q_DEFINE_THIS_FILE


void BSP_ledOff() {

	cout << "LED OFF" << endl;
}

void BSP_ledOn() {

	cout << "LED ON" << endl;
}


Blinky::Blinky() : QActive(Q_STATE_CAST(&Blinky::initial)) /*, m_timeEvt(this, TIMEOUT_SIG, 0U) */
{}

// This is teh state that will be called by the QF framework, when the task get started.
Q_STATE_DEF(Blinky, initial) {
	(void)e;
	//m_timeEvt.armX(BSP_TICKS_PER_SEC / 2, BSP_TICKS_PER_SEC / 2);
	// Symbollic names for state handlers.
	QS_FUN_DICTIONARY(&Blinky::off);
	QS_FUN_DICTIONARY(&Blinky::on);

	cout << "initial" << endl;
	// Transition to the off state.
	return tran(&off);
}

Q_STATE_DEF(Blinky, off) {

	QState status_;

	switch (e->sig) {
		case Q_ENTRY_SIG: {
			BSP_ledOff();
			status_ = Q_RET_HANDLED;
			cout << "OFF: EEEE is called" << endl;
			break;
		}
#if 1
		case Q_EXIT_SIG: {
			status_ = Q_RET_HANDLED;
			cout << "OFF: XXXX is called" << endl;
			break;
		}
#endif
		case TIMEOUT_SIG: {
			status_ = tran(&on);
			cout << "OFF: TTTT is called" << endl;
			break;
		}
		default: {
			status_ = super(&top);
			break;
		}
	}
	return status_;
}

Q_STATE_DEF(Blinky, on) {

	QState status_;

	switch (e->sig) {
		case Q_ENTRY_SIG: {
			BSP_ledOn();
			status_ = Q_RET_HANDLED;
			cout << "ON: EEEE is called" << endl;
			break;
		}
#if 1
		case Q_EXIT_SIG: {
			status_ = Q_RET_HANDLED;
			cout << "ON: XXXX is called" << endl;
			break;
		}
#endif
		case TIMEOUT_SIG: {
			cout << "ON: TTTT is called" << endl;
			status_ = tran(&on);
			break;
		}
		default: {
			status_ = super(&top);
			break;
		}
	}
	return status_;
}





